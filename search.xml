<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>%2F2017%2F05%2F01%2Farticle3%2F</url>
      <content type="text"><![CDATA[1.从作用域讲起 js中作用域可分为：全局变量和局部变量。且规定：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。闭包的产生使得能在函数外部获取函数内部的局部变量。 注意：在函数内部声明变量时，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量。 2.闭包定义 闭包是一个函数，通常也被称为闭包函数。该函数运行在一个特定的环境中，该环境中定义了一些本地变量，当该函数被调用时，仍可以使用这些本地变量。 3.闭包(函数)的两种基本类型 (1)作为值从函数返回的函数就是闭包函数 例如：闭包函数A()位于一个特定的环境中（即函数B()中），并作为值从函数B()返回： function B() { var temp = “abc”; //本地变量 function A() //闭包函数 { alert(“闭包函数处理本地变量temp的值：” + temp); } return A; //返回闭包函数 } var myFunc = B(); //调用函数B()，返回的是闭包函数A() myFunc(); //调用闭包函数A(),结果返回”闭包函数处理本地变量temp的值：abc” 分析：myFunc()调用是在函数B()外边，按照规定，它不应该再返回到本地变量temp，但实际上仍可以访问到，这就是闭包函数的作用。 (2)利用变量作用范围也可以形成闭包函数 一般来讲，作为参数传递给函数的函数或作为值从函数返回的函数都是闭包函数。同时，利用变量作用范围也可以形成闭包函数，例如“ var F; function B() { var temp = &quot;abc&quot;; F = function() { alert(&quot;闭包函数处理本地变量temp的值：&quot; + temp); } } B(); //调用函数B()为变量F赋值； F(); //调用闭包函数F() 分析，闭包函数F()的调用虽不在函数B()的局部作用范围内，但仍可以访问到temp。 注意：自由变量跨作用域取值时，要去创建这个函数的作用域取值，而不是“父作用域”。（其他篇章再分析） 4.闭包函数的总结 (1)用处：一是可以读取函数内部的变量，二是可以让这些变量的值始终保持在内存中，不会让其被调用后被自动清除。 关于第二个用处的解释：B()是A()的父函数，而A()被赋给了一个全局变量，这导致A()始终在内存中，而A()的存在依赖于B()，因此B()也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 (2)缺点：一是内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 二是闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[this的值是什么]]></title>
      <url>%2F2017%2F05%2F01%2Farticle2%2F</url>
      <content type="text"><![CDATA[1.函数调用 首先需要从函数的调用开始讲起。 JS（ES5）里面有三种函数调用形式： func(p1, p2) obj.child.method(p1, p2) func.call(context, p1, p2) // 先不讲 apply 前面两种是常见的形式，其实后一种才是正常调用形式： func.call(context, p1, p2) 前两种可以等价地变为 call 形式： func(p1, p2) 等价于 func.call(undefined, p1, p2) obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2) 请记下来。（我们称此代码为「转换代码」，方便下文引用） 至此我们的函数调用只有一种形式： func.call(context, p1, p2) 这样，this 就好解释了–this，就是上面代码中的 context。就这么简单。 先看 func(p1, p2) 中的 this 如何确定： 当你写下面代码时 function func(){ console.log(this) } func()等价于： function func(){ console.log(this) } func.call(undefined) // 可以简写为 func.call() 按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则： 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） 因此上面的打印结果是 window。 如果你希望这里的 this 不是 window，很简单： func.call(obj) // 那么里面的 this 就是 obj 对象了 再看 obj.child.method(p1, p2) 的 this 如何确定 var obj = { foo: function(){ console.log(this) } } obj.foo() 按照「转换代码」，我们将 obj.foo() 转换为 obj.foo.call(obj) 好了，this 就是 obj。搞定。 回到题目： var obj = { foo: function(){ console.log(this) } } var bar = obj.foo obj.foo() // 转换为obj.foo.call(obj)，this 就是 obj bar() // 转换为 bar.call() // 由于没有传 context // 所以 this 就是 undefined // 最后浏览器给你一个默认的 this —— window 对象 [ ] 语法 function fn (){ console.log(this) } var arr = [fn, fn2] arr[0]() // 这里面的 this 又是什么呢？ 我们可以把 arr0 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了： arr0，假想为 arr.0()然后转换为 arr.0.call(arr)那么里面的 this 就是 arr 了 :) 总结 this 就是你 call 一个函数时，传入的 context。 如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。 2.this机制的四种规则 this到底绑定或者引用的是哪个对象环境决定于函数被调用的地方。而函数的调用有不同的方式，在不同的方式中调用决定this引用的是哪个对象是由四种规则确定的。我们一个个来看。 2.1 默认绑定全局变量 这条规则是最常见的，也是默认的。当函数被单独定义和调用的时候，应用的规则就是绑定全局变量。如下： function fn() { console.log( this.a ); } var a = 2; fn(); // 2 -- fn单独调用，this引用window 2.2 隐式绑定 隐式调用的意思是，函数调用时拥有一个上下文对象，就好像这个函数是属于该对象的一样。例如： function fn() { console.log( this.a ); } var obj = { a: 2, fn: fn }; obj.fn(); // 2 -- this引用obj。 需要说明的一点是，最后一个调用该函数的对象是传到函数的上下文对象（绕懵了）。如： function fn() { console.log( this.a ); } var obj2 = { a: 42, fn: fn }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.fn(); // 42 -- this引用的是obj2. 还有一点要说明的是，失去隐式绑定的情况，如下： function fn() { console.log( this.a ); } var obj = { a: 2, fn: fn }; var bar = obj.fn; // 函数引用传递 var a = &quot;全局&quot;; // 定义全局变量 bar(); // &quot;全局&quot; 如上，第8行虽然有隐式绑定，但是它执行的效果明显是把fn赋给bar。这样bar执行的时候，依然是默认绑定全局变量，所以输出结果如上。 2.3 显示绑定 学过bind()\apply()\call()函数的都应该知道，它接收的第一个参数即是上下文对象并将其赋给this。看下面的例子： function fn() { console.log( this.a ); } var obj = { a: 2 }; fn.call( obj ); // 2 如果我们传递第一个值为简单值，那么后台会自动转换为对应的封装对象。如果传递为null，那么结果就是在绑定默认全局变量，如： function fn() { console.log( this.a ); } var obj = { a: 2 }; var a = 10; fn.call( null); // 10 2.4 new新对象绑定 如果是一个构造函数，那么用new来调用，那么绑定的将是新创建的对象。如： function fn(a) { this.a = a; } var bar = new fn( 2 ); console.log( bar.a );// 2 注意，一般构造函数名首字母大写，这里没有大写的原因是想提醒读者，构造函数也是一般的函数而已。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何用Hexo和Github搭建个人博客]]></title>
      <url>%2F2017%2F04%2F22%2Farticle1%2F</url>
      <content type="text"><![CDATA[前言——关于为什么搭建个人博客 很多人都用过QQ空间和微博，虽然它们可以满足我们发表日志、照片等动态的需求，但是其界面基本大同小异。而个人博客则可以由我们自身个性化地行搭建装饰，你可以在上面诉说你的生活琐事，也可以发表你对行业的独特见解。作为想要立志在互联网行业拼搏的人，博客的搭建是你对所学知识应用的开始，而运营博客则体现一个人的水平及修养。 步骤说明 1.什么是Hexo? Hexo是一个开源的静态博客生成器,用node.js开发。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.从配置Github开始 首先注册或登录github.com，记住自己的用户名，之后点击右上角Create a new repository， 配置生成自己仓库，其中yourname.github.io就是你的博客域名，例如我的域名是http://github.com/youglin 3.环境安装（node.js、git bash和文本编辑器） （1）Node.js可在其官网根据自己电脑的配置进行安装就行了。但是git for windows直接从国内官网下载比较困难，我的做法是下载一个翻墙软件（叫什么加速器来着），可以免费使用一小时，用它下载git bash。文本编辑器我推荐的是Notepad++，用来更改配置文件。 安装好之后在cmd面板中输入命令检查是否安装成功，如下： 安装成功之后，git bash需要进行一些配置，大概就是下面一些命令，如不明白请自行搜索。 git config --global user.email email为你注册Github时的邮箱地址 git config --global user.name name为你注册Github时的用户名 ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 接着系统生成ssh，在Blog中找到.ssh文件夹打开（Notepad++），复制里面内容，登陆github，依次点击settings － SSH keys － add ssh keys（把上面复制的内容全部添加进去即可） 4.安装hexo 在cmd面板中输入 : npm install -g hexo-cli 看到相关的成功提示后即可。 5.生成hexo 在电脑D盘（自己定）新建文件夹Blog，打开Blog，按住Shift键点击鼠标右键，再点击“在此处打开命令窗口”，输入： hexo init blog 稍等之后，系统成功提示： INFO Start blogging with Hexo! 此后，hexo指的就是你的Blog文件夹里的文件。hexo生成之后其source目录中带有一篇hello world的文章，接着你在面板中执行 hexo generate（也可写作hexo g，表示生成新内容） 再启动本地服务器： hexo server 之后在浏览器输入http://localhost:4000/就可以看见网页和模板了。系统成功提示： INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 6.将博客发布到Github （1）部署之前先修改Blog/_config.yml文件（冒号后面一定要有空格，如下面”type:”和”git”之间有空格。） deploy: type: git repository: https://github.com/youglin/youglin.github.io.git (youglin替换为你自己的用户名) branch: master （2）进行发布，即在面板中输入： hexo deploy 注：如果执行上述命令报错，你可以试试下面这个命令再试。 npm install hexo-deployer-git--save （3）部署成功后，你在浏览器中输入youglin.github.io，就能看到和本地一样的效果了。(youglin改为你的用户名） 注意： 如果使用cmd面板发布博客过程报错，从官网下载Github桌面版，解压安装到指定文件夹之后，在桌面会生成如下两个快捷方式： 其中Git Shell可用来代替cmd面板发布博客，Github可用于将hexo文件上传到你的线上Github仓库中，方法可自行搜索。 7.配置博客 在Blog目录下，用Notepad++打开_config.yml文件，参数信息如下： # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site #站点信息 title: #标题 subtitle: #副标题 description: #站点描述，给搜索引擎看的 author: #作者 email: #电子邮箱 language: zh-CN #语言 # URL #链接格式 url: #网址 root: / #根目录 ...... 特别提醒，在每个参数的：后都要加一个空格 修改网站相关信息: title: 你的博客标题subtitle: 副标题description: 网页描述author: 林language: zh-CNtimezone: #这里不要改动，保持默认状态 8.更改主题 hexo默认的主题为landscape，相信很多人都觉得不够炫，网上有很多的hexo主题，我用的是Next，其配置方式较为简单，直接在Next官网根据其提示进行相应的操作即可。 9.发表新文章 在cmd（如果不行，用Git Shell)中输入： cd D:\test（定位到hexo目录中） hexo new &quot;新文章标题&quot; 系统提示：INFO Created: D:\test\source\_posts\新文章标题.md 在该目录下找到该文章，打开，使用Markdown语法，该语法介绍可以上网查看。 --- title: 崔斯特测试文章 date: 2017-02-28 13:03:44 tags: --- 这是一篇测试文章，欢迎关注作者博客[1]: https://youglin.github.io/ 保存文章更改，然后执行下列步骤： hexo generate INFO Start processing INFO Files loaded in 1.48 s #省略 INFO 29 files generated in 4.27 s cd D:\test hexo server INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 再发布到网上 cd D:\test hexo deploy INFO Deploying: git INFO Clearing .deploy_git folder... INFO Copying files from public folder... #省略 10.总结 1.为什么我的博客网址显示的是www.yourlin.cn我不是youglin.github.io，因为yourlin.cn是我在腾讯云的域名，并且我把Github中博客的域名youglin.github.io映射到了www.yourlin.cn中，因此两个都可以访问到。 2.这也是我第一次搭建个人博客，前后用了几天时间，看了网上的很多教程，也请教了我的同学，还有很多功能需要去完善和开发，一起努力吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F20%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
